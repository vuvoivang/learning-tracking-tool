{"id":"64ecbb62b065beb378c318f1","name":"Count Complete Tree Nodes","description":"<p style=\"margin-left:0px;\">Given the <code>root</code> of a <strong>complete</strong> binary tree, return the number of the nodes in the tree.</p><p style=\"margin-left:0px;\">According to <a href=\"http://en.wikipedia.org/wiki/Binary_tree#Types_of_binary_trees\"><strong>Wikipedia</strong></a>, every level, except possibly the last, is completely filled in a complete binary tree, and all nodes in the last level are as far left as possible. It can have between <code>1</code> and <code>2<sup>h</sup></code> nodes inclusive at the last level <code>h</code>.</p><p style=\"margin-left:0px;\">Design an algorithm that runs in less than&nbsp;<code>O(n)</code>&nbsp;time complexity.</p><p style=\"margin-left:0px;\">&nbsp;</p><p style=\"margin-left:0px;\"><strong>Example 1:</strong></p><figure class=\"image image_resized\" style=\"width:372px;\"><img src=\"https://assets.leetcode.com/uploads/2021/01/14/complete.jpg\" alt=\"\"></figure><p><strong>Input:</strong> root = [1,2,3,4,5,6]\n<strong>Output:</strong> 6\n</p><p style=\"margin-left:0px;\"><strong>Example 2:</strong></p><p><strong>Input:</strong> root = []\n<strong>Output:</strong> 0\n</p><p style=\"margin-left:0px;\"><strong>Example 3:</strong></p><p><strong>Input:</strong> root = [1]\n<strong>Output:</strong> 1\n</p><p style=\"margin-left:0px;\">&nbsp;</p><p style=\"margin-left:0px;\"><strong>Constraints:</strong></p><ul><li>The number of nodes in the tree is in the range <code>[0, 5 * 10<sup>4</sup>]</code>.</li><li><code>0 &lt;= Node.val &lt;= 5 * 10<sup>4</sup></code></li><li>The tree is guaranteed to be <strong>complete</strong>.</li></ul>","price":300000000,"increase":true,"difficulty":"Hard","solution":"<h1 style=\"margin-left:0px;\"><strong>Intuition</strong></h1><h1 style=\"margin-left:0px;\"><strong>Approach</strong></h1><ul><li>We declare count as global variable outside the function</li><li>Inside the function we have the termination condition for recursion i.e.<br>root != null</li><li>Then comes the recursive tree traversal till the termination condition is satified, alongside traversal increment the count using count++.</li></ul><h1 style=\"margin-left:0px;\"><strong>Code</strong></h1><pre><code class=\"language-plaintext\">/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    //counter variable\n    int count = 0;\n    public int countNodes(TreeNode root) {\n    \n        if(root != null){\n        countNodes(root.left);\n        count++;        \n        countNodes(root.right);\n        }\n\n            return count;\n    }\n}</code></pre>","createDate":"2023-08-28T22:21:06.878Z","finishedDate":null,"comments":[],"status":0,"normalizedName":"COUNT COMPLETE TREE NODES","type":0}
